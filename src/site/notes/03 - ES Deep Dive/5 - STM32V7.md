---
{"dg-publish":true,"permalink":"/03-es-deep-dive/5-stm-32-v7/","noteIcon":"","created":"2024-06-07T18:25:54.958+02:00","updated":"2024-06-18T11:23:24.746+02:00"}
---

## 知识点 (有待进一步理解)
- what is DTCM and ITCM?
	- ITCM用于运行指令
	- DTCM用于数据存取
		- 和内核的速度一样（我猜是CPU？）
	- HAL库和标准库之间的区别？
- ARM中的缓存
	- L1 Cache 一级缓存
- 仿真器，下载器具体的实现
- 如何看出![Z - assets/images/Pasted image 20240607224607.png](/img/user/Z%20-%20assets/images/Pasted%20image%2020240607224607.png)

## 知识点（有待进一步整理）
 - BSP
	 - board support package
		 - 对于HAL的另一层封装
		 - board（板）级不同硬件资源的支持
			 - 主要是外围设备映射的不同内存地址？
- CMSIS
	- `Cortex Microcontroller Software Interface Standard`![Z - assets/images/Pasted image 20240607210253.png](/img/user/Z%20-%20assets/images/Pasted%20image%2020240607210253.png)
		- peripheral register declarations
		- bit definitions
		- address mapping
	- directories
		- `Core`
			- Cortex-M处理器内核和外设的API
		- `Driver`
			- 支持的外设![Z - assets/images/Pasted image 20240607215204.png](/img/user/Z%20-%20assets/images/Pasted%20image%2020240607215204.png)
			- 针对不同厂商的产品，例如STM32H7，ARM推出一个驱动包
				- 对HAL进一步封装，底层调用HAL中的API
		- `SVD`
			- System View Description
			- 对芯片的外设，存储器等进行了详细的描述，编译器需要使用到这个文件
	- Event Recorder
		- SWV (`Serial Wire Viewer`)
			- ITM (`Instrumentation Trace Macrocell`)
			- SWO
				- 输出格式
					- `UART`
					- `Manchester`
		- `DWT`时钟计数器
			- data watchpoint and trace unit
				- a debug unit that provides watchpoints and system profiling for the processor
			- a **full** contains four comparators which can be configured as
				- a hardware watchpoint (+4)
				- an ETM tigger (what is this?)
				- a PC sampler event trigger (PC pointer?)
				- a data address sampler event trigger (memory ish?)
		- `printf`重定向
			- MDK调试组件中的 Debug(`printf`) Viewer
		- 使用`SWD`接口的`SWO`引脚是可以实现串口打印的
			- 也是通过调试调试组件中的 Debug(`printf`) Viewer
			```C
			/* Event Record */
			typedef struct {
			  uint32_t ts;                  // Timestamp (32-bit, Toggle bit instead of MSB)
			  uint32_t val1;                // Value 1   (32-bit, Toggle bit instead of MSB)
			  uint32_t val2;                // Value 2   (32-bit, Toggle bit instead of MSB)
			  uint32_t info;                // Record Information
			                                //  [ 7.. 0]: Message ID (8-bit)
			                                //  [15.. 8]: Component ID (8-bit)
			                                //  [18..16]: Data Length (1..8) / Event Context
			                                //      [19]: IRQ Flag
			                                //  [23..20]: Sequence Number
			                                //      [24]: First Record
			                                //      [25]: Last Record
			                                //      [26]: Locked Record
			                                //      [27]: Valid Record
			                                //      [28]: Timestamp MSB
			                                //      [29]: Value 1 MSB
			                                //      [30]: Value 2 MSB
			                                //      [31]: Toggle bit
			} EventRecord_t;
			```
			- 16 bytes
			- first 4 bytes representing the event ID
	- MPU
		- memory protection unit
		- what it does
			- memory protection
			- **peripheral protection**
			- privileged code access protection
	- 堆栈指针寄存器R13
		- MSP：主进程堆栈指针
			- 由`OS`内核，异常服务例程以及所有需要特权访问的应用程序代码使用
			- [ ] try it out in a real application
		- PSP: 进程堆栈指针
			- 不处于异常服务例程中的常规应用程序代码、
			- 多用于RTOS中
				- 为什么需要设计两个不同的堆栈指针？
		- `R13`的最低两位总是读出`0`
			- 堆栈总是`4`字节对齐的
				- 结论显然意见，最后两位相当于bit mask
	- 向下生长的满栈
			![Z - assets/images/Pasted image 20240615003823.png](/img/user/Z%20-%20assets/images/Pasted%20image%2020240615003823.png)
	- clock resources
		- `ppm`
			- parts per millions
			- example
				```markdown
				An accuracy of 40 ppm at 25°C means that for 1 million ticks of clock, the maximum deviation will be 40 ticks of clock.
				// 1e6 ticks per second
				
				For one day, the maximum deviation is 24 * 60 * 60 * 40E6 = 3.46 seconds
				```
	- peripheral initialization
		- example: how the UART is initialized
		```c
		/**
		  * @brief Initialize the UART mode according to the specified
		  *        parameters in the UART_InitTypeDef and initialize the associated handle.
		  * @param huart: UART handle.
		  * @retval HAL status
		  */
		HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
		{
		  /* Check the UART handle allocation */
		  if(huart == NULL)
		  {
		    return HAL_ERROR;
		  }
		
		  if(huart->Init.HwFlowCtl != UART_HWCONTROL_NONE)
		  {
		    /* Check the parameters */
		    assert_param(IS_UART_HWFLOW_INSTANCE(huart->Instance));
		  }
		  else
		  {
		    /* Check the parameters */
		    assert_param((IS_UART_INSTANCE(huart->Instance)) || (IS_LPUART_INSTANCE(huart->Instance)));
		  }
		
		  if(huart->gState == HAL_UART_STATE_RESET)
		  {
		    /* Allocate lock resource and initialize it */
		    huart->Lock = HAL_UNLOCKED;
		
		    /* Init the low level hardware : GPIO, CLOCK */
		    HAL_UART_MspInit(huart);
		  }
		
		  huart->gState = HAL_UART_STATE_BUSY;
		
		  /* Disable the Peripheral */
		  __HAL_UART_DISABLE(huart);
		
		  /* Set the UART Communication parameters */
		  if (UART_SetConfig(huart) == HAL_ERROR)
		  {
		    return HAL_ERROR;
		  }
		
		  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
		  {
		    UART_AdvFeatureConfig(huart);
		  }
		
		  /* In asynchronous mode, the following bits must be kept cleared:
		  - LINEN and CLKEN bits in the USART_CR2 register,
		  - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
		  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
		  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
		
		  /* Enable the Peripheral */
		  __HAL_UART_ENABLE(huart);
		
		  /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
		  return (UART_CheckIdleState(huart));
		}
		```
		- `HAL_UART_MspInit`
			- user-defined UART initialization
		- take-away
			- framework (design pattern)
				- weak function to allow user (application) specific definition
					- `HAL_UART_ErrorCallBack`
	- `SysTick`
		- System Tick timer
		- integrated as a part of the **NVIC**
			- generate the SysTick exception (type `#15`)
		- run on processor clock frequency or from a reference clock frequency
		- modern operating system requires a periodic interrupt to ensure that the OS kernel can invoke regularly
			- e.x. task management and context switching
			- applications running at unprivileged level can't disable the **SysTick** timer
		- have it inside the processor to help **software portability**
		- *used as a simple peripheral for periodic interrupt generation*
		- how to schedule the SysTick interrupt for one-shot operation
			- reduce the reload value by **12** cycles to compensate for the interrupt latency
				- HOW to measure the interrupt latency ???
		- `count_flag`
			- `SysTick` is a decrement counter
			- the duration measured by the `SysTick` can get underflowed
				- in this case, the `count_flag` is set
				- `SysTick` exception needs to be enabled and the times that the `SysTick` counter underflows can be counted in the handler
		- calibration
			- hardware register
			- software variables
		- considerations
			- registers can ONLY be accessed when in privileged state
			- `SysTick` timer can be used by the OS which should not be used by the application tasks then
			- `SysTick` timer stops counting when the processor is halted during debugging
			- `SysTick` timer may stop in certain sleep modes
	- 启动过程
		- 启动文件
			- 设置初始堆栈指针
			- 设置初始PC指针
			- 设置中断向量表
			- 配置系统时钟
			- 配置外部SRAM/SDRAM用于程序变量等数据存储
			- 跳转到C库中的`__main`
				- 进一步调用用户程序中的`main`
		- `Cortex-M`内核处理器复位后，处于线程模式(thread mode)，指令权限是特权级别，堆栈设置为使用主堆栈MSP
		- 复位时序逻辑
			- 取出堆栈栈顶地址存放到MSP中
			- 取出向量表地址装入PC中
			- 向量表中的第一条指令就是复位中断服务程序`Reset_Handler`
				- 调用`SystemInit()`来配置时钟和`FMC`总线上的外部SRAM或者SDRAM
				- 跳转到`__main`函数
					- 完成用户程序的初始化工作
					- 调用用户程序中的`main`
		```c
		Stack_Size      EQU     0x00001000
		
		                AREA    STACK, NOINIT, READWRITE, ALIGN=3
		Stack_Mem       SPACE   Stack_Size
		__initial_sp
		```
		- `EQU` 
			- 宏定义的伪指令
				- 不会生成二进制程序代码，也不会引起变量空间分配
		- `ARER`
			- 定义一个代码段或者数据段
				- `STACK` 段的名字
				- `NOINIT` 此段数据不需要填入初始数据
				- `READWRITE` 此段可读可写
				- `ALIGN=3` 首地址按照2的3次方对齐
		- `SPACE`
			- 分配给`STACK`给定字节的连续内存空间
		- `__initial_sp`
			- 紧跟`SPACE`语句，表示了栈顶地址
		```c
		Heap_Size       EQU     0x0000800
		
		                AREA    HEAP, NOINIT, READWRITE, ALIGN=3
		__heap_base
		Heap_Mem        SPACE   Heap_Size
		__heap_limit
		```
		- `__heap_base`
			- 表示堆的开始地址
		- `__heap_limit`
			- 表示堆的结束地址
		```c
		                PRESERVE8
		                THUMB
		
		
		; Vector Table Mapped to Address 0 at Reset
		                AREA    RESET, DATA, READONLY
		                EXPORT  __Vectors
		                EXPORT  __Vectors_End
		                EXPORT  __Vectors_Size
		```
		- `PRESERVE8`
			- 指定当前文件保持堆栈8字节对齐
		- `THUMB`
			- 表示后面的指令是`THUMB`指令集
		- `EXPORT`
			- 将3个标号申明为可被外部引用，主要提供给链接器用于连接库文件或其它文件
		```c
			__Vectors       DCD     __initial_sp                      ; Top of Stack
			                DCD     Reset_Handler                     ; Reset Handler
			                DCD     NMI_Handler                       ; NMI Handler
			                DCD     HardFault_Handler                 ; Hard Fault Handler
			                DCD     MemManage_Handler                 ; MPU Fault Handler
			                DCD     BusFault_Handler                  ; Bus Fault Handler
			                DCD     UsageFault_Handler                ; Usage Fault Handler
			
			__Vectors_End
			
			__Vectors_Size  EQU  __Vectors_End - __Vectors
		```
		- 定义中断向量表
			- 代码段的最前面
			- 内存中的具体物理地址由链接器的配置参数决定
			- `DCD`表示分配1个4Bytes的空间
				- 生成一个4 Bytes的二进制代码
			```c
			                AREA    |.text|, CODE, READONLY
			
			; Reset handler
			Reset_Handler    PROC
			                 EXPORT  Reset_Handler                    [WEAK]
			        IMPORT  SystemInit
			        IMPORT  __main
			
			                 LDR     R0, =SystemInit
			                 BLX     R0
			                 LDR     R0, =__main
			                 BX      R0
			                 ENDP
			```
		- `|.text|` 段名
		- `PROC / ENDP`
		- `[WEAK]`
			- `WEAK`声明其他的同名标号优先于该标号被引用
		- `IMPORT`
			- 通知编译器使用的symbol在其它的源文件中定义
			- 该symbol会被加入到当前源文件的符号表中无论当前源文件是否引用该symbol
		- `SystemInit`
			- 跳转`__user_initial_stackheap`进行堆栈初始化
		```c
		Default_Handler PROC                                      
		                EXPORT  WWDG_IRQHandler                   [WEAK]                                       		
		WWDG_IRQHandler                                                          
		WAKEUP_PIN_IRQHandler
		                B       .
		                ENDP
		                ALIGN
		```
		- ` B       .`
			- 死循环，用户使能中断服务程序而且没有在C文件里面定义中断服务程序的话
		```c
		                 IF      :DEF:__MICROLIB
		                
		                 EXPORT  __initial_sp
		                 EXPORT  __heap_base
		                 EXPORT  __heap_limit
		                
		                 ELSE
		                
		                 IMPORT  __use_two_region_memory
		                 EXPORT  __user_initial_stackheap
		                 
		__user_initial_stackheap
		
		                 LDR     R0, =  Heap_Mem
		                 LDR     R1, =(Stack_Mem + Stack_Size)
		                 LDR     R2, = (Heap_Mem +  Heap_Size)
		                 LDR     R3, = Stack_Mem
		                 BX      LR
		
		                 ALIGN
		
		                 ENDIF
		
		                 END
		```
		- `__user_initial_stackheap`
			- `__main`函数调用
		- BOOT启动模式
			- 1个`boot`引脚
				- *对应32位地址到高16位*
			- 选项字节**掉电不会丢失**
			- 设置的地址不在有效范围时
				- `BOOT = 0` 从Flash首地址启动
				- `BOOT = 1` 从ITCM首地址启动
			- 使能`Flash Level 2`,则只能从Flash地址空间进行启动
![Z - assets/images/Pasted image 20240618111935.png](/img/user/Z%20-%20assets/images/Pasted%20image%2020240618111935.png)